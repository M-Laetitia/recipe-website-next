# Indique à CircleCI la version de configuration utilisée
version: 2.1

# Import d’un “orb” : un module réutilisable CircleCI pour Node.js
orbs:
  node: circleci/node@5.1.1
  # Fournit des commandes préconfigurées comme `node/install`, `node/install-packages`
  github-cli: circleci/github-cli@2.0

# Définition d’un job : un ensemble d’étapes exécutées dans un environnement donné
jobs:
  build-and-test:
    docker:
      # Premier conteneur Docker principal : Node.js (ici cimg/node:20.1)
      - image: cimg/node:20.1
        # Cette image contient une version moderne de Node.js, utilisée pour ton projet Next.js

      # Deuxième conteneur : MongoDB, utilisé comme service pour exécuter les tests
      - image: mongo:5.0
        # Conteneur Mongo officiel – version 5.0 (à adapter si besoin)

    # Variables d’environnement injectées dans les deux conteneurs
    environment:
      MONGODB_URI: mongodb://localhost:27017/myproject_test
      #  pointe vers la base de données MongoDB qui est lancée dans le deuxième conteneur Docker (mongo:5.0) défini dans la configuration.
      NODE_ENV: test
      # Permet à ton code de savoir qu’il tourne en environnement de test
      # La variable MONGODB_URI sera utilisée par ton ORM ou client MongoDB

    # Étapes à exécuter dans ce job
    steps:
      - checkout
        # Clone ton dépôt Git dans le conteneur

      - node/install
        # Installe Node.js via l’orb, en se basant sur `.nvmrc` ou `package.json` si précisé

      - restore_cache:
          keys:
            - deps-{{ checksum "package-lock.json" }}
            - deps-
        # Essaie de restaurer un cache existant des dépendances Node.js pour accélérer le build
        # `{{ checksum "package-lock.json" }}` permet de valider que c’est bien le même jeu de dépendances

      - node/install-packages
        # Lance automatiquement `npm install` ou `yarn install` selon le lockfile détecté

      - save_cache:
          paths:
            - node_modules
          key: deps-{{ checksum "package-lock.json" }}
        # Sauvegarde le cache des dépendances après installation pour les prochaines exécutions

      - run:
          name: Wait for MongoDB
          command: |
            for i in `seq 1 20`; do
              nc -z localhost 27017 && echo "MongoDB is up!" && break
              echo "Waiting for MongoDB..."
              sleep 2
            done
        # Attente active : vérifie toutes les 2 secondes pendant 40s que MongoDB est bien lancé
        # Important car sinon les tests peuvent échouer si Mongo n’est pas prêt

      - run:
          name: Run Tests
          command: npm run test
        # Exécute les tests définis dans le script `"test"` de ton package.json
        # Ces tests doivent se connecter à la base MongoDB via MONGODB_URI


  create-pull-request:
    docker:
      - image: cimg/base:2023.03
    parameters:
      source-branch:
        type: string
      target-branch:
        type: string
      title:
        type: string
        default: "Automatic PR"
    steps:
      - checkout
      - github-cli/setup:
          token: GITHUB_TOKEN
      - run:
          name: Create Pull Request
          command: |
            # Vérifie si une PR existe déjà entre les branches source et target
            existing_pr=$(gh pr list --state open --base << parameters.target-branch >> --head << parameters.source-branch >> --json number --jq "length")
            
            if [ "$existing_pr" -eq "0" ]; then
              echo "Création d'une nouvelle PR de << parameters.source-branch >> vers << parameters.target-branch >>"
              gh pr create --base << parameters.target-branch >> --head << parameters.source-branch >> \
                --title "<< parameters.title >>" \
                --body "Cette PR a été créée automatiquement par le pipeline CI/CD après validation des tests."
            else
              echo "Une PR existe déjà entre << parameters.source-branch >> et << parameters.target-branch >>. Aucune nouvelle PR créée."
            fi

  deploy-to-vercel:
    docker:
      - image: cimg/node:20.1
    steps:
      - checkout
      - node/install
      - node/install-packages
      - run:
          name: Install Vercel CLI
          command: npm install -g vercel
      - run:
          name: Deploy to Vercel
          command: |
            # Déploiement sur Vercel avec l'environnement de production
            vercel --prod --token ${VERCEL_TOKEN}

workflows:
  version: 2
  ci-cd-pipeline:
    jobs:
      # Tests sur la branche dev
      - build-and-test:
          name: test-dev
          filters:
            branches:
              only: dev

      # Création de PR de dev vers test après tests réussis
      - create-pull-request:
          name: pr-dev-to-test
          requires:
            - test-dev
          parameters:
            source-branch: "dev"
            target-branch: "test"
            title: "Merge dev into test"
          filters:
            branches:
              only: dev

      # Tests sur la branche test
      - build-and-test:
          name: test-test
          filters:
            branches:
              only: test

      # Création de PR de test vers main après tests réussis
      - create-pull-request:
          name: pr-test-to-main
          requires:
            - test-test
          parameters:
            source-branch: "test"
            target-branch: "main"
            title: "Merge test into main"
          filters:
            branches:
              only: test

      # Déploiement sur Vercel après merge sur main
      - deploy-to-vercel:
          requires:
            - build-and-test
          filters:
            branches:
              only: main




# + deploy require bluid and test
# Juste ci pas de cd

# on push sur dev ou pull request vers dev
# lint > estlint + test 
# pull request de dev vers test + ci obligatoire revue de code possible avec la pull resquest (git) puis fusion manuelle si tout se passe bien c'est ici qu'on valide
# la branche test que du code véfiié
# puis fusion vers main pull request

# début test unitaire puis avant de main test end to end 

# puis déploiement auto sur vercel

# push dev
# dev
# pull resquet avect test
# branche test
# pull request avec main


#ajuste un ci pas un cd, pipeline check si les test passent avant tout déploiement

# > faire en sorte que les tests se fassent sur l'env. test 